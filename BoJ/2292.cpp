/*https://www.acmicpc.net/problem/2292
벌집

벌집구조의 방이 있다. 방이 돌아가며 1씩증가하는 번호로 주소가 매겨짐.
1번방부터 N번방까지 가는데 최소 몇개의 방을 건너는지 계산하라.abort

[입력]
N (1~1,000,000,000,000)

[출력]
최소방개수


[풀이]
결국, 1에서부터 시작해서 해당 숫자까지가는데
둘레 몇겹을 통과하는지 보는 것인지 확인하라는 것으로 보임.abort

규칙이 있어보인다.
- 1 (1겹)
- 7 (2겹) (+6)
- 19 (3겹) (+12)
- 37 (4겹) (+18)
- 61 (5겹) (+24)

즉, 각 마지막 방은 이전 마지막방 보다 6의배수로 커지고있음.abort

방1 -> 방2 (6*1)+1 -> 방3(6*1 + 6*2)+1 -> 방4(6*1 + 6*2 + 6*3)+1
각 방의 마지막 숫자는
-> 6(1~N합)
-> 나머지값은 6으로 더해야할듯
= N+1 방

13은 방 몇겹?
-> 13 -> 6*2 + 1 -> 6 * 3 -> 1+2 -> 2겹 +1 -> 방3

61은 방 몇겹?
-> 61 -> 61 = 6*10 + 1 -> 6*10 + 6 -> 11 = 1+2+3+4
-> 4겹
-> 방5

40은 방 몇겹?
- 40 -> 40 = 6*6 +4 -> 6*7 -> 7 = 1+2+3+ ... 값이 모자라니 +1
-> 4겹 + 1
= 5방 (ㅋㅋㅋㅋ 수식 개판이네 ㅋㅋ;;)


[맞추긴 했는데 이건 맞춘게 아니다..]
- 찾은 규칙과 방향은 동일하다.
- 다만, 직접 그 방값을 찾아가는 방식으로 만듬.
    - 나는 6과 N의 곱에 미쳐서 수식 맞추려고 환장을 했음.
    - 다음에 풀때는, 처음부터 제대로 무식하고 깔끔하게 푸는 방향으로 시작하자.
*/
#include <bits/stdc++.h>
using namespace std;
int _N, _roomValue, _numCnt;

int main()
{
    cin >> _N;
    if(_N == 1)
    {
        cout << 1;
        return 0;
    }
    _roomValue = _N-1;
    if(_roomValue %6)
    {
        _roomValue /=6;
        _roomValue++;
    }
    else
        _roomValue /=6;
    
    _numCnt = 1;
    int numCntSum = 0;
    while(true)
    {
        numCntSum += _numCnt;
        if(numCntSum >= _roomValue)
            break;
        _numCnt++;
    }

    cout << _numCnt +1;
    return 0;
}